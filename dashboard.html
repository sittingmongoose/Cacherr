<!DOCTYPE html>
<html>
<head>
    <title>Cacherr Dashboard</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }
        .container { max-width: 1400px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .header { text-align: center; margin-bottom: 30px; }
        .status-card { background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 6px; padding: 20px; margin-bottom: 20px; }
        .status-running { border-left: 4px solid #28a745; }
        .status-idle { border-left: 4px solid #6c757d; }
        .btn { background: #007bff; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; margin: 5px; }
        .btn:hover { background: #0056b3; }
        .btn-danger { background: #dc3545; }
        .btn-danger:hover { background: #c82333; }
        .btn-success { background: #28a745; }
        .btn-success:hover { background: #218838; }
        .btn-warning { background: #ffc107; color: #212529; }
        .btn-warning:hover { background: #e0a800; }
        .btn-secondary { background: #6c757d; color: white; }
        .btn-secondary:hover { background: #545b62; }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin: 20px 0; }
        .stat-card { background: white; border: 1px solid #dee2e6; border-radius: 6px; padding: 15px; text-align: center; }
        .stat-value { font-size: 2em; font-weight: bold; color: #007bff; }
        .stat-label { color: #6c757d; margin-top: 5px; }
        .log-container { background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 6px; padding: 15px; max-height: 300px; overflow-y: auto; }
        .log-entry { margin: 5px 0; padding: 5px; border-radius: 3px; }
        .log-info { background: #d1ecf1; }
        .log-warning { background: #fff3cd; }
        .log-error { background: #f8d7da; }
        .test-results { background: #e7f3ff; border: 1px solid #b3d9ff; border-radius: 6px; padding: 15px; margin: 20px 0; }
        .file-detail { background: white; border: 1px solid #dee2e6; border-radius: 4px; padding: 10px; margin: 5px 0; }
        .file-path { font-family: monospace; font-size: 0.9em; color: #495057; }
        .file-size { font-weight: bold; color: #28a745; }
        .nav-tabs { display: flex; border-bottom: 1px solid #dee2e6; margin-bottom: 20px; }
        .nav-tab { padding: 10px 20px; cursor: pointer; border: none; background: none; border-bottom: 2px solid transparent; }
        .nav-tab.active { border-bottom-color: #007bff; color: #007bff; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .form-group { margin-bottom: 15px; }
        .form-label { display: block; margin-bottom: 5px; font-weight: bold; }
        .form-input { width: 100%; padding: 8px; border: 1px solid #ced4da; border-radius: 4px; box-sizing: border-box; }
        .form-textarea { width: 100%; padding: 8px; border: 1px solid #ced4da; border-radius: 4px; box-sizing: border-box; min-height: 60px; }
        .form-select { width: 100%; padding: 8px; border: 1px solid #ced4da; border-radius: 4px; box-sizing: border-box; }
        .form-checkbox { margin-right: 8px; }
        .form-help { color: #6c757d; font-size: 0.875em; margin-top: 5px; display: block; }
        .settings-section { background: white; border: 1px solid #dee2e6; border-radius: 6px; padding: 20px; margin-bottom: 20px; }
        .validation-result { padding: 10px; border-radius: 4px; margin: 10px 0; }
        .validation-success { background: #d4edda; border: 1px solid #c3e6cb; color: #155724; }
        .validation-error { background: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; }
        .validation-warning { background: #fff3cd; border: 1px solid #ffeaa7; color: #856404; }
        .path-status { display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-right: 8px; }
        .path-ok { background: #28a745; }
        .path-error { background: #dc3545; }
        .path-warning { background: #ffc107; }
        
        /* Real-time watcher styles */
        .watcher-info { background: #f0f8ff; border: 1px solid #b3d9ff; border-radius: 6px; padding: 15px; margin: 20px 0; }
        .watcher-stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin: 15px 0; }
        .watch-history { margin-top: 20px; }
        .history-list { max-height: 300px; overflow-y: auto; }
        .history-item { background: white; border: 1px solid #dee2e6; border-radius: 4px; padding: 10px; margin: 5px 0; }
        .history-title { font-weight: bold; color: #007bff; margin-bottom: 5px; }
        .history-details { display: flex; gap: 15px; font-size: 0.9em; color: #6c757d; }
        .history-type { background: #e9ecef; padding: 2px 8px; border-radius: 12px; }
        .history-reason { flex: 1; }
        .history-time { color: #495057; }
        .btn-info { background: #17a2b8; }
        .btn-info:hover { background: #138496; }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; }
        
        .cache-removal-info, .user-activity-info {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .removal-schedule, .user-activity {
            margin-top: 15px;
        }
        
        .removal-list, .user-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .removal-item, .user-item {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .removal-media, .user-name {
            font-weight: bold;
            color: #495057;
        }
        
        .removal-time {
            color: #6c757d;
            font-size: 0.9em;
        }
        
        .user-details {
            display: flex;
            gap: 15px;
            align-items: center;
            font-size: 0.9em;
        }
        
        .user-active {
            border-left: 4px solid #28a745;
        }
        
        .user-inactive {
            background-color: #dc3545;
            color: white;
        }
        
        .status-badge {
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: bold;
        }
        
        /* Trakt.tv Styles */
        .trakt-controls {
            margin-bottom: 20px;
        }
        
        .trakt-controls .btn {
            margin-right: 10px;
            margin-bottom: 10px;
        }
        
        .trakt-status {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .status-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }
        
        .trending-movies {
            margin-top: 20px;
        }
        
        .movie-list {
            display: grid;
            gap: 15px;
        }
        
        .movie-item {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .movie-title {
            font-size: 1.1em;
            font-weight: bold;
            color: #495057;
            margin-bottom: 10px;
        }
        
        .movie-details {
            display: grid;
            gap: 5px;
            font-size: 0.9em;
            color: #6c757d;
        }
        
        .movie-details div {
            display: flex;
            justify-content: space-between;
        }
        
        .movie-details div:before {
            content: attr(data-label);
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸŽ¬ Cacherr Dashboard</h1>
            <p>Docker-optimized Plex media caching system with enhanced features</p>
        </div>
        
        <div class="nav-tabs">
            <button class="nav-tab active" onclick="showTab('dashboard')">Dashboard</button>
            <button class="nav-tab" onclick="showTab('settings')">Settings</button>
            <button class="nav-tab" onclick="showTab('logs')">Logs</button>
        </div>
        
        <!-- Dashboard Tab -->
        <div id="dashboard" class="tab-content active">
            <div class="status-card" id="statusCard">
                <h3>System Status</h3>
                <p id="statusText">Loading...</p>
                <div>
                    <button class="btn btn-success" onclick="runCache()">Run Cache Operation</button>
                    <button class="btn btn-warning" onclick="runTestMode()">Run Test Mode</button>
                    <button class="btn btn-success" onclick="startScheduler()">Start Scheduler</button>
                    <button class="btn btn-danger" onclick="stopScheduler()">Stop Scheduler</button>
                </div>
                
                <div style="margin-top: 15px;">
                    <h4>Real-Time Plex Watching</h4>
                    <button class="btn btn-info" onclick="startWatcher()" id="startWatcherBtn">Start Watcher</button>
                    <button class="btn btn-warning" onclick="stopWatcher()" id="stopWatcherBtn">Stop Watcher</button>
                    <button class="btn btn-secondary" onclick="clearWatchHistory()">Clear History</button>
                </div>
            </div>
            
            <div class="stats-grid" id="statsGrid">
                <div class="stat-card">
                    <div class="stat-value" id="filesToCache">-</div>
                    <div class="stat-label">Files to Cache</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="filesToArray">-</div>
                    <div class="stat-label">Files to Array</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="lastExecution">-</div>
                    <div class="stat-label">Last Execution</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="schedulerStatus">-</div>
                    <div class="stat-label">Scheduler Status</div>
                </div>
            </div>
            
            <div class="test-results" id="testResults" style="display: none;">
                <h3>Test Mode Results</h3>
                <div id="testResultsContent"></div>
            </div>
            
            <div class="watcher-info">
                <h4>Real-Time Watcher Status</h4>
                <div class="watcher-stats">
                    <div class="stat-item">
                        <strong>Status:</strong> <span id="watcherStatus">Unknown</span>
                    </div>
                    <div class="stat-item">
                        <strong>Active Sessions:</strong> <span id="activeSessions">0</span>
                    </div>
                    <div class="stat-item">
                        <strong>Total Watches:</strong> <span id="totalWatches">0</span>
                    </div>
                    <div class="stat-item">
                        <strong>Media Cached:</strong> <span id="mediaCached">0</span>
                    </div>
                    <div class="stat-item">
                        <strong>Media Removed:</strong> <span id="mediaRemoved">0</span>
                    </div>
                    <div class="stat-item">
                        <strong>Scheduled Removals:</strong> <span id="scheduledRemovals">0</span>
                    </div>
                </div>
            </div>

            <div class="cache-removal-info">
                <h4>Cache Removal Schedule</h4>
                <div id="cacheRemovalSchedule" class="removal-schedule">
                    <p>No scheduled removals</p>
                </div>
            </div>

            <div class="user-activity-info">
                <h4>User Activity Status</h4>
                <div id="userActivityStatus" class="user-activity">
                    <p>No user activity data</p>
                </div>
            </div>
            
            <!-- Trakt.tv Trending Movies -->
            <div id="traktTrendingMovies">
                <h4>Trakt.tv Trending Movies</h4>
                <div class="trakt-controls">
                    <button class="btn btn-primary" onclick="startTraktWatcher()">Start Trakt Watcher</button>
                    <button class="btn btn-warning" onclick="stopTraktWatcher()">Stop Trakt Watcher</button>
                    <button class="btn btn-secondary" onclick="clearTraktHistory()">Clear History</button>
                    <button class="btn btn-info" onclick="refreshTraktData()">Refresh</button>
                </div>
                <div class="trakt-status">
                    <div class="status-item">
                        <strong>Status:</strong> <span id="traktStatus">Unknown</span>
                    </div>
                    <div class="status-item">
                        <strong>Trending Movies:</strong> <span id="traktMovieCount">0</span>
                    </div>
                    <div class="status-item">
                        <strong>Last Check:</strong> <span id="traktLastCheck">Never</span>
                    </div>
                    <div class="status-item">
                        <strong>Movies Added:</strong> <span id="traktMoviesAdded">0</span>
                    </div>
                    <div class="status-item">
                        <strong>Movies Removed:</strong> <span id="traktMoviesRemoved">0</span>
                    </div>
                </div>
                <div class="trending-movies">
                    <div class="movie-list" id="trendingMoviesList">
                        <!-- Trending movies will be populated here -->
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Settings Tab -->
        <div id="settings" class="tab-content">
            <div class="settings-section">
                <h3>Configuration Settings</h3>
                <div class="form-group">
                    <button class="btn btn-secondary" onclick="loadSettings()">Load Current Settings</button>
                    <button class="btn btn-success" onclick="saveSettings()">Save Settings</button>
                    <button class="btn btn-danger" onclick="resetSettings()">Reset to Defaults</button>
                </div>
                
                <div id="validationResult"></div>
                
                <form id="settingsForm">
                    <h4>Plex Configuration</h4>
                    <div class="form-group">
                        <label class="form-label">Plex URL:</label>
                        <input type="text" class="form-input" id="plex_url" name="plex[url]" placeholder="https://plex.yourdomain.com">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Plex Token:</label>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <input type="password" class="form-input" id="plex_token" name="plex[token]" placeholder="your_plex_token" style="flex: 1;">
                            <button type="button" id="validatePlexBtn" class="btn btn-secondary" onclick="validatePlexConnection()">Validate</button>
                        </div>
                        <div id="plexValidationResult" style="margin-top: 8px;"></div>
                    </div>
                    
                    <h4>Path Configuration</h4>

                    <div class="form-group">
                        <label class="form-label">Plex Source:</label>
                        <input type="text" class="form-input" id="plex_source" name="paths[plex_source]" placeholder="/media">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Cache Destination (Optional):</label>
                        <input type="text" class="form-input" id="cache_destination" name="paths[cache_destination]" placeholder="/mnt/cache/media">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Additional Sources:</label>
                        <div class="info-box" style="background: #e7f3ff; border: 1px solid #b3d9ff; border-radius: 6px; padding: 15px; margin: 10px 0;">
                            <p><strong>Note:</strong> Additional sources are configured via Docker environment variables only.</p>
                            <p>Use <code>ADDITIONAL_SOURCES</code> and <code>ADDITIONAL_PLEX_SOURCES</code> in your docker-compose.yml or Unraid template.</p>
                            <p>Values should be <strong>space-separated</strong>, not comma-separated.</p>
                            <p><strong>Example:</strong> <code>ADDITIONAL_SOURCES=/mediasource2 /mediasource3 /mediasource4</code></p>
                        </div>
                    </div>
                    
                    <h4>Media Settings</h4>
                    <div class="form-group">
                        <label class="form-label">Number of Episodes:</label>
                        <input type="number" class="form-input" id="number_episodes" name="media[number_episodes]" value="5">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Days to Monitor:</label>
                        <input type="number" class="form-input" id="days_to_monitor" name="media[days_to_monitor]" value="99">
                    </div>
                    <div class="form-group">
                        <label class="form-label">
                            <input type="checkbox" class="form-checkbox" id="watchlist_toggle" name="media[watchlist_toggle]" checked>
                            Enable Watchlist Caching
                        </label>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Watchlist Episodes:</label>
                        <input type="number" class="form-input" id="watchlist_episodes" name="media[watchlist_episodes]" value="1">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Watchlist Cache Expiry (hours):</label>
                        <input type="number" class="form-input" id="watchlist_cache_expiry" name="media[watchlist_cache_expiry]" value="6">
                    </div>
                    <div class="form-group">
                        <label class="form-label">
                            <input type="checkbox" class="form-checkbox" id="watched_move" name="media[watched_move]" checked>
                            Move Watched Content to Array
                        </label>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Watched Cache Expiry (hours):</label>
                        <input type="number" class="form-input" id="watched_cache_expiry" name="media[watched_cache_expiry]" value="48">
                    </div>
                    <div class="form-group">
                        <label class="form-label">
                            <input type="checkbox" class="form-checkbox" id="users_toggle" name="media[users_toggle]" checked>
                            Enable Multi-User Support
                        </label>
                    </div>
                    <div class="form-group">
                        <label class="form-label">
                            <input type="checkbox" class="form-checkbox" id="exit_if_active_session" name="media[exit_if_active_session]">
                            Exit on Active Plex Sessions
                        </label>
                    </div>
                    
                    <h4>ðŸ†• Copy vs Move Behavior</h4>
                    <div class="form-group">
                        <label class="form-label">
                            <input type="checkbox" class="form-checkbox" id="copy_to_cache" name="media[copy_to_cache]">
                            Copy to Cache (instead of moving)
                        </label>
                        <small class="form-help">When enabled, files are copied to cache, preserving originals in source locations</small>
                    </div>
                    <div class="form-group">
                        <label class="form-label">
                            <input type="checkbox" class="form-checkbox" id="delete_from_cache_when_done" name="media[delete_from_cache_when_done]" checked>
                            Delete from Cache When Done
                        </label>
                        <small class="form-help">When copy mode is enabled, delete files from cache instead of moving them back</small>
                    </div>
                    <div class="form-group">
                        <label class="form-label">
                            <input type="checkbox" class="form-checkbox" id="use_symlinks_for_cache" name="media[use_symlinks_for_cache]" checked>
                            Use Symlinks for Cache
                        </label>
                        <small class="form-help">Create symlinks so Plex automatically uses cached files</small>
                    </div>
                    <div class="form-group">
                        <label class="form-label">
                            <input type="checkbox" class="form-checkbox" id="move_with_symlinks" name="media[move_with_symlinks]">
                            ðŸ†• Move + Symlink Mode (Hybrid)
                        </label>
                        <small class="form-help">Move files to cache and create symlinks back - frees source space while keeping Plex happy</small>
                    </div>
                    <div class="form-group">
                        <small style="color: #6c757d; font-style: italic;">ðŸ’¡ <strong>Copy mode</strong> preserves your originals while still providing fast cache performance. <strong>Move+Symlink mode</strong> frees source space while keeping Plex library intact.</small>
                    </div>
                    
                    <h4>Performance Settings</h4>
                    <div class="form-group">
                        <label class="form-label">Max Concurrent Moves to Cache:</label>
                        <input type="number" class="form-input" id="max_concurrent_moves_cache" name="performance[max_concurrent_moves_cache]" value="5">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Max Concurrent Moves to Array:</label>
                        <input type="number" class="form-input" id="max_concurrent_moves_array" name="performance[max_concurrent_moves_array]" value="2">
                    </div>
                    
                    <h5>ðŸ†• Per-Source Concurrency Control</h5>
                    <div class="form-group">
                        <label class="form-label">Max Concurrent Local Transfers (Server):</label>
                        <input type="number" class="form-input" id="max_concurrent_local_transfers" name="performance[max_concurrent_local_transfers]" value="5" min="1" max="10">
                        <small class="form-help">Higher values for fast local server transfers (SSD/HDD)</small>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Max Concurrent Network Transfers (NAS):</label>
                        <input type="number" class="form-input" id="max_concurrent_network_transfers" name="performance[max_concurrent_network_transfers]" value="2" min="1" max="5">
                        <small class="form-help">Lower values for network/NAS transfers to avoid congestion</small>
                    </div>
                    <div class="form-group">
                        <small style="color: #6c757d; font-style: italic;">ðŸ’¡ These settings allow different concurrency limits for local server transfers vs. network NAS transfers, optimizing performance for each source type.</small>
                    </div>
                    
                    <h4>Test Mode Settings</h4>
                    <div class="form-group">
                        <label class="form-label">
                            <input type="checkbox" class="form-checkbox" id="test_mode" name="test_mode[enabled]">
                            Enable Test Mode
                        </label>
                    </div>
                    <div class="form-group">
                        <label class="form-label">
                            <input type="checkbox" class="form-checkbox" id="test_show_file_sizes" name="test_mode[show_file_sizes]" checked>
                            Show File Sizes in Test Mode
                        </label>
                    </div>
                    <div class="form-group">
                        <label class="form-label">
                            <input type="checkbox" class="form-checkbox" id="test_show_total_size" name="test_mode[show_total_size]" checked>
                            Show Total Size in Test Mode
                        </label>
                    </div>
                    <div class="form-group">
                        <small style="color: #28a745; font-style: italic;">âœ… Test mode is always safe - files are never moved during testing</small>
                    </div>
                    
                    <h3>Real-Time Plex Watching</h3>
                    <div class="form-group">
                        <label for="real_time_watch_enabled">Enable Real-Time Watching:</label>
                        <input type="checkbox" id="real_time_watch_enabled" name="real_time_watch[enabled]">
                    </div>
                    <div class="form-group">
                        <label for="real_time_watch_check_interval">Check Interval (seconds):</label>
                        <input type="number" id="real_time_watch_check_interval" name="real_time_watch[check_interval]" min="10" max="300">
                    </div>
                    <div class="form-group">
                        <label for="real_time_watch_auto_cache_on_watch">Auto-Cache on Watch Start:</label>
                        <input type="checkbox" id="real_time_watch_auto_cache_on_watch" name="real_time_watch[auto_cache_on_watch]">
                    </div>
                    <div class="form-group">
                        <label for="real_time_watch_cache_on_complete">Cache on Watch Complete:</label>
                        <input type="checkbox" id="real_time_watch_cache_on_complete" name="real_time_watch[cache_on_complete]">
                    </div>
                    <div class="form-group">
                        <label for="real_time_watch_respect_existing_rules">Respect Existing Rules:</label>
                        <input type="checkbox" id="real_time_watch_respect_existing_rules" name="real_time_watch[respect_existing_rules]">
                    </div>
                    <div class="form-group">
                        <label for="real_time_watch_max_concurrent_watches">Max Concurrent Watches:</label>
                        <input type="number" id="real_time_watch_max_concurrent_watches" name="real_time_watch[max_concurrent_watches]" min="1" max="50">
                    </div>
                    <div class="form-group">
                        <label for="real_time_watch_remove_from_cache_after_hours">Remove from Cache After (hours):</label>
                        <input type="number" id="real_time_watch_remove_from_cache_after_hours" name="real_time_watch[remove_from_cache_after_hours]" min="0" max="720">
                        <small>0 = never remove automatically</small>
                    </div>
                    <div class="form-group">
                        <label for="real_time_watch_respect_other_users_watchlists">Respect Other Users' Watchlists:</label>
                        <input type="checkbox" id="real_time_watch_respect_other_users_watchlists" name="real_time_watch[respect_other_users_watchlists]">
                        <small>Keep media in cache if other users have it in their watchlists</small>
                    </div>
                    <div class="form-group">
                        <label for="real_time_watch_exclude_inactive_users_days">Exclude Inactive Users (Days)</label>
                        <input type="number" id="real_time_watch_exclude_inactive_users_days" name="real_time_watch[exclude_inactive_users_days]" class="form-control" min="1" max="365">
                        <small class="form-text text-muted">Users inactive for this many days will be excluded from caching considerations</small>
                    </div>
                    
                    <!-- Trakt.tv Settings -->
                    <div class="settings-section">
                        <h4>Trakt.tv Integration</h4>
                        <div class="form-group">
                            <label for="trakt_enabled">Enable Trakt.tv Integration</label>
                            <input type="checkbox" id="trakt_enabled" name="trakt[enabled]" class="form-checkbox">
                            <small class="form-text text-muted">Enable automatic caching of trending movies from Trakt.tv</small>
                        </div>
                        <div class="form-group">
                            <label for="trakt_client_id">Trakt Client ID</label>
                            <input type="text" id="trakt_client_id" name="trakt[client_id]" class="form-input">
                            <small class="form-text text-muted">Your Trakt.tv API client ID</small>
                        </div>
                        <div class="form-group">
                            <label for="trakt_client_secret">Trakt Client Secret</label>
                            <input type="password" id="trakt_client_secret" name="trakt[client_secret]" class="form-input">
                            <small class="form-text text-muted">Your Trakt.tv API client secret</small>
                        </div>
                        <div class="form-group">
                            <label for="trakt_trending_movies_count">Trending Movies Count</label>
                            <input type="number" id="trakt_trending_movies_count" name="trakt[trending_movies_count]" class="form-input" min="1" max="50">
                            <small class="form-text text-muted">Number of trending movies to include for caching</small>
                        </div>
                        <div class="form-group">
                            <label for="trakt_check_interval">Check Interval (Seconds)</label>
                            <input type="number" id="trakt_check_interval" name="trakt[check_interval]" class="form-input" min="60" max="86400">
                            <small class="form-text text-muted">How often to check for new trending movies</small>
                        </div>
                    </div>
                    
                    <!-- Web Interface Settings -->
                    <h4>Other Settings</h4>
                    <div class="form-group">
                        <label class="form-label">Log Level:</label>
                        <select class="form-select" id="log_level" name="logging[level]">
                            <option value="DEBUG">DEBUG</option>
                            <option value="INFO" selected>INFO</option>
                            <option value="WARNING">WARNING</option>
                            <option value="ERROR">ERROR</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">
                            <input type="checkbox" class="form-checkbox" id="debug" name="debug">
                            Enable Debug Mode
                        </label>
                    </div>
                </form>
            </div>
        </div>
        
        <!-- Logs Tab -->
        <div id="logs" class="tab-content">
            <div class="status-card">
                <h3>Recent Logs</h3>
                <div style="margin-bottom: 15px;">
                    <button class="btn btn-secondary" onclick="refreshLogs()">Refresh Logs</button>
                    <button class="btn btn-info" onclick="clearLogs()">Clear Display</button>
                </div>
                <div class="log-container" id="logContainer">
                    <div class="log-entry log-info">Loading logs...</div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        let scheduler_running = false;
        
        function showTab(tabName) {
            // Hide all tab contents
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(tab => tab.classList.remove('active'));
            
            // Remove active class from all tabs
            const tabs = document.querySelectorAll('.nav-tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            // Show selected tab
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
            
            // Load data for specific tabs
            if (tabName === 'dashboard') {
                updateStatus();
            } else if (tabName === 'settings') {
                loadSettings();
            } else if (tabName === 'logs') {
                loadLogs();
            }
        }
        
        function updateStatus() {
            fetch('/api/status')
                .then(response => response.json())
                .then(data => {
                    const statusCard = document.getElementById('statusCard');
                    const statusText = document.getElementById('statusText');
                    const filesToCache = document.getElementById('filesToCache');
                    const filesToArray = document.getElementById('filesToArray');
                    const lastExecution = document.getElementById('lastExecution');
                    const schedulerStatus = document.getElementById('schedulerStatus');
                    
                    // Update status
                    if (data.status === 'running') {
                        statusCard.className = 'status-card status-running';
                        statusText.textContent = 'System is currently running';
                    } else {
                        statusCard.className = 'status-card status-idle';
                        statusText.textContent = 'System is idle';
                    }
                    
                    // Update stats
                    filesToCache.textContent = data.pending_operations.files_to_cache;
                    filesToArray.textContent = data.pending_operations.files_to_array;
                    lastExecution.textContent = data.last_execution.execution_time || 'Never';
                    schedulerStatus.textContent = scheduler_running ? 'Running' : 'Stopped';
                    
                    // Update test results if available
                    if (data.test_results) {
                        updateTestResults(data.test_results);
                    }
                })
                .catch(error => {
                    console.error('Error fetching status:', error);
                });
        }
        
        function updateTestResults(testResults) {
            const testResultsDiv = document.getElementById('testResults');
            const testResultsContent = document.getElementById('testResultsContent');
            
            if (Object.keys(testResults).length === 0) {
                testResultsDiv.style.display = 'none';
                return;
            }
            
            testResultsDiv.style.display = 'block';
            let html = '';
            
            for (const [operation, data] of Object.entries(testResults)) {
                if (data.file_count > 0) {
                    html += `<h4>${operation.replace('_', ' ').toUpperCase()} Operation</h4>`;
                    html += `<p><strong>Files:</strong> ${data.file_count} | <strong>Total Size:</strong> ${data.total_size_readable}</p>`;
                    
                    if (data.file_details && data.file_details.length > 0) {
                        html += '<div class="file-details">';
                        data.file_details.forEach(file => {
                            html += `
                                <div class="file-detail">
                                    <div class="file-path">${file.filename}</div>
                                    <div class="file-size">${file.size_readable}</div>
                                    <div class="file-path">${file.directory}</div>
                                </div>
                            `;
                        });
                        html += '</div>';
                    }
                }
            }
            
            testResultsContent.innerHTML = html;
        }
        
        function loadSettings() {
            fetch('/api/settings')
                .then(response => response.json())
                .then(data => {
                    // Populate form fields
                    document.getElementById('plex_url').value = data.data.plex?.url || '';
                    // Handle token display - show masked value if token exists in backend
                    const tokenFromAPI = data.data.plex?.token || '';
                    const tokenField = document.getElementById('plex_token');
                    if (tokenFromAPI === '***') {
                        // Backend has a token but it's masked for security - show placeholder
                        tokenField.value = 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢';
                        tokenField.setAttribute('data-has-backend-token', 'true');
                    } else if (tokenFromAPI) {
                        // Actual token value (shouldn't happen in normal API responses)
                        tokenField.value = tokenFromAPI;
                        tokenField.removeAttribute('data-has-backend-token');
                    } else {
                        // No token configured
                        tokenField.removeAttribute('data-has-backend-token');
                    }
                    
                    document.getElementById('plex_source').value = data.data.paths?.plex_source || '';
                    document.getElementById('cache_destination').value = data.data.paths?.cache_destination || '';

                    
                    document.getElementById('number_episodes').value = data.data.media?.number_episodes || 5;
                    document.getElementById('days_to_monitor').value = data.data.media?.days_to_monitor || 99;
                    document.getElementById('watchlist_toggle').checked = data.data.media?.watchlist_toggle || false;
                    document.getElementById('watchlist_episodes').value = data.data.media?.watchlist_episodes || 1;
                    document.getElementById('watchlist_cache_expiry').value = data.data.media?.watchlist_cache_expiry || 6;
                    document.getElementById('watched_move').checked = data.data.media?.watched_move || false;
                    document.getElementById('watched_cache_expiry').value = data.data.media?.watched_cache_expiry || 48;
                    document.getElementById('users_toggle').checked = data.data.media?.users_toggle || false;
                    document.getElementById('exit_if_active_session').checked = data.data.media?.exit_if_active_session || false;
                    document.getElementById('copy_to_cache').checked = data.data.media?.copy_to_cache || false;
                    document.getElementById('delete_from_cache_when_done').checked = data.data.media?.delete_from_cache_when_done || false;
                    document.getElementById('use_symlinks_for_cache').checked = data.data.media?.use_symlinks_for_cache || false;
                    document.getElementById('move_with_symlinks').checked = data.data.media?.move_with_symlinks || false;
                    
                    document.getElementById('max_concurrent_moves_cache').value = data.data.performance?.max_concurrent_moves_cache || 5;
                    document.getElementById('max_concurrent_moves_array').value = data.data.performance?.max_concurrent_moves_array || 2;
                    document.getElementById('max_concurrent_local_transfers').value = data.data.performance?.max_concurrent_local_transfers || 5;
                    document.getElementById('max_concurrent_network_transfers').value = data.data.performance?.max_concurrent_network_transfers || 2;
                    
                    document.getElementById('test_mode').checked = data.data.test_mode?.enabled || false;
                    document.getElementById('test_show_file_sizes').checked = data.data.test_mode?.show_file_sizes || false;
                    document.getElementById('test_show_total_size').checked = data.data.test_mode?.show_total_size || false;
            
                    
                    document.getElementById('real_time_watch_enabled').checked = data.data.real_time_watch?.enabled || false;
                    document.getElementById('real_time_watch_check_interval').value = data.data.real_time_watch?.check_interval || 30;
                    document.getElementById('real_time_watch_auto_cache_on_watch').checked = data.data.real_time_watch?.auto_cache_on_watch || false;
                    document.getElementById('real_time_watch_cache_on_complete').checked = data.data.real_time_watch?.cache_on_complete || false;
                    document.getElementById('real_time_watch_respect_existing_rules').checked = data.data.real_time_watch?.respect_existing_rules || false;
                    document.getElementById('real_time_watch_max_concurrent_watches').value = data.data.real_time_watch?.max_concurrent_watches || 5;
                    document.getElementById('real_time_watch_remove_from_cache_after_hours').value = data.data.real_time_watch?.remove_from_cache_after_hours || 0;
                    document.getElementById('real_time_watch_respect_other_users_watchlists').checked = data.data.real_time_watch?.respect_other_users_watchlists || false;
                    document.getElementById('real_time_watch_exclude_inactive_users_days').value = data.data.real_time_watch?.exclude_inactive_users_days || 0;
                    
                    document.getElementById('trakt_enabled').checked = data.data.trakt?.enabled || false;
                    document.getElementById('trakt_client_id').value = data.data.trakt?.client_id || '';
                    document.getElementById('trakt_client_secret').value = data.data.trakt?.client_secret || '';
                    document.getElementById('trakt_trending_movies_count').value = data.data.trakt?.trending_movies_count || 10;
                    document.getElementById('trakt_check_interval').value = data.data.trakt?.check_interval || 3600;
                    
                    document.getElementById('log_level').value = data.data.logging?.level || 'INFO';
                    document.getElementById('debug').checked = data.data.debug || false;
                })
                .catch(error => {
                    console.error('Error loading settings:', error);
                    alert('Error loading settings');
                });
        }
        
        function saveSettings() {
            const formData = new FormData(document.getElementById('settingsForm'));
            const settings = {};
            
            // Debug: Log all form data entries
            console.log('Form data entries:');
            for (const [key, value] of formData.entries()) {
                console.log(`${key}: ${value}`);
            }
            
            // Handle all checkboxes explicitly (unchecked checkboxes don't appear in FormData)
            const form = document.getElementById('settingsForm');
            const checkboxes = form.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                const name = checkbox.name;
                const isChecked = checkbox.checked;
                
                if (name.includes('[') && name.includes(']')) {
                    const match = name.match(/^([^\[]+)\[([^\]]+)\]$/);
                    if (match) {
                        const section = match[1];
                        const setting = match[2];
                        
                        if (!settings[section]) {
                            settings[section] = {};
                        }
                        settings[section][setting] = isChecked;
                    }
                } else if (name.includes('_')) {
                    const parts = name.split('_');
                    const section = parts[0];
                    const setting = parts.slice(1).join('_');
                    
                    if (!settings[section]) {
                        settings[section] = {};
                    }
                    settings[section][setting] = isChecked;
                } else {
                    settings[name] = isChecked;
                }
            });
            
            // Convert form data to settings object (for non-checkbox fields)
            for (const [key, value] of formData.entries()) {
                // Skip checkboxes - they're handled explicitly above
                const inputElement = form.querySelector(`[name="${key}"]`);
                if (inputElement && inputElement.type === 'checkbox') {
                    continue;
                }
                
                // Handle bracket notation (e.g., plex[url] -> plex.url)
                if (key.includes('[') && key.includes(']')) {
                    const match = key.match(/^([^\[]+)\[([^\]]+)\]$/);
                    if (match) {
                        const section = match[1];
                        const setting = match[2];
                        
                        if (!settings[section]) {
                            settings[section] = {};
                        }
                        
                        settings[section][setting] = value;
                    }
                } else if (key.includes('_')) {
                    const parts = key.split('_');
                    const section = parts[0];
                    const setting = parts.slice(1).join('_');
                    
                    if (!settings[section]) {
                        settings[section] = {};
                    }
                    
                    settings[section][setting] = value;
                } else {
                    settings[key] = value;
                }
            }
            

            
            // Handle performance settings with proper nesting
            if (formData.get('performance[max_concurrent_moves_cache]')) {
                if (!settings.performance) settings.performance = {};
                settings.performance.max_concurrent_moves_cache = parseInt(formData.get('performance[max_concurrent_moves_cache]'));
            }
            if (formData.get('performance[max_concurrent_moves_array]')) {
                if (!settings.performance) settings.performance = {};
                settings.performance.max_concurrent_moves_array = parseInt(formData.get('performance[max_concurrent_moves_array]'));
            }
            if (formData.get('performance[max_concurrent_local_transfers]')) {
                if (!settings.performance) settings.performance = {};
                settings.performance.max_concurrent_local_transfers = parseInt(formData.get('performance[max_concurrent_local_transfers]'));
            }
            if (formData.get('performance[max_concurrent_network_transfers]')) {
                if (!settings.performance) settings.performance = {};
                settings.performance.max_concurrent_network_transfers = parseInt(formData.get('performance[max_concurrent_network_transfers]'));
            }
            
            // Debug: Log the settings object being sent
            console.log('Settings being sent:', settings);
            
            fetch('/api/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(settings)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('Settings saved successfully!');
                } else {
                    alert('Error saving settings: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Error saving settings:', error);
                alert('Error saving settings');
            });
        }
        
        function validateSettings() {
            const formData = new FormData(document.getElementById('settingsForm'));
            const settings = {};
            
            // Convert form data to settings object
            for (const [key, value] of formData.entries()) {
                // Handle bracket notation (e.g., plex[url] -> plex.url)
                if (key.includes('[') && key.includes(']')) {
                    const match = key.match(/^([^\[]+)\[([^\]]+)\]$/);
                    if (match) {
                        const section = match[1];
                        const setting = match[2];
                        
                        if (!settings[section]) {
                            settings[section] = {};
                        }
                        
                        if (value === 'on') {
                            settings[section][setting] = true;
                        } else if (value === 'off') {
                            settings[section][setting] = false;
                        } else {
                            settings[section][setting] = value;
                        }
                    }
                } else if (key.includes('_')) {
                    const parts = key.split('_');
                    const section = parts[0];
                    const setting = parts.slice(1).join('_');
                    
                    if (!settings[section]) {
                        settings[section] = {};
                    }
                    
                    if (value === 'on') {
                        settings[section][setting] = true;
                    } else if (value === 'off') {
                        settings[section][setting] = false;
                    } else {
                        settings[section][setting] = value;
                    }
                } else {
                    settings[key] = value;
                }
            }
            
            // Handle special cases for comma-separated values

            
            fetch('/api/settings/validate', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(settings)
            })
            .then(response => response.json())
            .then(data => {
                displayValidationResults(data);
            })
            .catch(error => {
                console.error('Error validating settings:', error);
                alert('Error validating settings');
            });
        }
        
        function displayValidationResults(results) {
            const validationDiv = document.getElementById('validationResult');
            let html = '';
            
            if (results.valid) {
                html += '<div class="validation-result validation-success">';
                html += '<strong>âœ“ Validation Successful!</strong> All settings are valid.';
                html += '</div>';
            } else {
                html += '<div class="validation-result validation-error">';
                html += '<strong>âœ— Validation Failed!</strong> Please fix the following errors:';
                html += '<ul>';
                results.errors.forEach(error => {
                    html += `<li>${error}</li>`;
                });
                html += '</ul>';
                html += '</div>';
            }
            
            if (results.warnings && results.warnings.length > 0) {
                html += '<div class="validation-result validation-warning">';
                html += '<strong>âš  Warnings:</strong>';
                html += '<ul>';
                results.warnings.forEach(warning => {
                    html += `<li>${warning}</li>`;
                });
                html += '</ul>';
                html += '</div>';
            }
            
            if (results.path_checks) {
                html += '<div class="validation-result">';
                html += '<strong>Path Validation Results:</strong><br>';
                
                for (const [pathName, pathInfo] of Object.entries(results.path_checks)) {
                    if (Array.isArray(pathInfo)) {
                        // Additional sources
                        html += `<div><strong>${pathName}:</strong><br>`;
                        pathInfo.forEach(source => {
                            const statusClass = source.exists ? 'path-ok' : 'path-warning';
                            const statusText = source.exists ? 'OK' : 'Missing';
                            html += `<span class="path-status ${statusClass}"></span>${source.path} (${statusText})<br>`;
                        });
                        html += '</div>';
                    } else {
                        // Single path
                        const statusClass = pathInfo.exists ? 'path-ok' : 'path-error';
                        const statusText = pathInfo.exists ? 'OK' : 'Missing';
                        html += `<span class="path-status ${statusClass}"></span>${pathName}: ${pathInfo.path} (${statusText})<br>`;
                    }
                }
                
                if (results.plex_connection) {
                    html += '<br><strong>Plex Connection:</strong><br>';
                    const plexStatus = results.plex_connection.status === 'success' ? 'path-ok' : 'path-error';
                    const plexText = results.plex_connection.status === 'success' ? 'Connected' : 'Failed';
                    html += `<span class="path-status ${plexStatus}"></span>${plexText}<br>`;
                }
                
                html += '</div>';
            }
            
            validationDiv.innerHTML = html;
        }
        
        function resetSettings() {
            if (confirm('Are you sure you want to reset all settings to defaults? This cannot be undone.')) {
                fetch('/api/settings/reset', { method: 'POST' })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            alert('Settings reset to defaults successfully!');
                            loadSettings(); // Reload the form
                        } else {
                            alert('Error resetting settings: ' + data.error);
                        }
                    })
                    .catch(error => {
                        console.error('Error resetting settings:', error);
                        alert('Error resetting settings');
                    });
            }
        }
        
        function runCache() {
            fetch('/api/run', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    alert(data.message);
                    setTimeout(updateStatus, 1000);
                })
                .catch(error => {
                    console.error('Error running cache:', error);
                    alert('Error running cache operation');
                });
        }
        
        function runTestMode() {
            fetch('/api/run', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ test_mode: true }) })
                .then(response => {
                    if (!response.ok) {
                        return response.json().then(errorData => {
                            throw new Error(errorData.error || 'HTTP error ' + response.status);
                        });
                    }
                    return response.json();
                })
                .then(data => {
                    alert(data.message);
                    setTimeout(updateStatus, 1000);
                })
                .catch(error => {
                    console.error('Error running test mode:', error);
                    alert('Error running test mode: ' + error.message);
                });
        }
        
        function validatePlexConnection() {
            const plexUrl = document.getElementById('plex_url').value.trim();
            const plexTokenField = document.getElementById('plex_token');
            const plexToken = plexTokenField.value.trim();
            const resultDiv = document.getElementById('plexValidationResult');
            const validateBtn = document.getElementById('validatePlexBtn');
            
            if (!plexUrl) {
                resultDiv.innerHTML = '<div style="color: #e74c3c; font-size: 0.9em;">âš ï¸ Please enter Plex URL</div>';
                return;
            }
            
            // Check if token is the masked placeholder and we have a backend token
            const hasBackendToken = plexTokenField.hasAttribute('data-has-backend-token');
            const isMaskedToken = plexToken === 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢';
            
            if (!plexToken || (isMaskedToken && !hasBackendToken)) {
                resultDiv.innerHTML = '<div style="color: #e74c3c; font-size: 0.9em;">âš ï¸ Please enter Plex Token</div>';
                return;
            }
            
            // Show loading state
            validateBtn.disabled = true;
            validateBtn.textContent = 'Validating...';
            resultDiv.innerHTML = '<div style="color: #3498db; font-size: 0.9em;">ðŸ”„ Validating Plex connection...</div>';
            
            // Prepare validation request
            const validationData = { url: plexUrl };
            
            if (isMaskedToken && hasBackendToken) {
                // Use stored backend token
                validationData.use_stored_token = true;
            } else {
                // Use provided token
                validationData.token = plexToken;
            }
            
            fetch('/api/validate-plex', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(validationData)
            })
            .then(response => response.json())
            .then(data => {
                validateBtn.disabled = false;
                validateBtn.textContent = 'Validate';
                
                if (data.success) {
                    resultDiv.innerHTML = `<div style="color: #27ae60; font-size: 0.9em;">âœ… ${data.message}</div>`;
                } else {
                    resultDiv.innerHTML = `<div style="color: #e74c3c; font-size: 0.9em;">âŒ ${data.error}</div>`;
                }
            })
            .catch(error => {
                validateBtn.disabled = false;
                validateBtn.textContent = 'Validate';
                console.error('Plex validation error:', error);
                resultDiv.innerHTML = '<div style="color: #e74c3c; font-size: 0.9em;">âŒ Connection failed - check console for details</div>';
            });
        }
        
        function startScheduler() {
            fetch('/api/scheduler/start', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    alert(data.message);
                    setTimeout(updateStatus, 1000);
                })
                .catch(error => {
                    console.error('Error starting scheduler:', error);
                    alert('Error starting scheduler');
                });
        }
        
        function stopScheduler() {
            fetch('/api/scheduler/stop', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    alert(data.message);
                    setTimeout(updateStatus, 1000);
                })
                .catch(error => {
                    console.error('Error stopping scheduler:', error);
                    alert('Error stopping scheduler');
                });
        }
        
        function startWatcher() {
            fetch('/api/watcher/start', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    alert(data.message);
                    setTimeout(updateStatus, 1000);
                })
                .catch(error => {
                    console.error('Error starting watcher:', error);
                    alert('Error starting real-time watcher');
                });
        }
        
        function stopWatcher() {
            fetch('/api/watcher/stop', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    alert(data.message);
                    setTimeout(updateStatus, 1000);
                })
                .catch(error => {
                    console.error('Error stopping watcher:', error);
                    alert('Error stopping real-time watcher');
                });
        }
        
        function clearWatchHistory() {
            if (confirm('Are you sure you want to clear the watch history? This cannot be undone.')) {
                fetch('/api/watcher/clear-history', { method: 'POST' })
                    .then(response => response.json())
                    .then(data => {
                        alert(data.message);
                        setTimeout(updateStatus, 1000);
                    })
                    .catch(error => {
                        console.error('Error clearing watch history:', error);
                        alert('Error clearing watch history');
                    });
            }
        }
        
        function updateWatcherInfo() {
            fetch('/api/watcher/status')
                .then(response => response.json())
                .then(data => {
                    // Update basic stats
                    document.getElementById('watcherStatus').textContent = data.is_watching ? 'Active' : 'Inactive';
                    document.getElementById('activeSessions').textContent = data.stats?.current_active_sessions || 0;
                    document.getElementById('totalWatches').textContent = data.stats?.total_watches_detected || 0;
                    document.getElementById('mediaCached').textContent = data.stats?.total_media_cached || 0;
                    document.getElementById('mediaRemoved').textContent = data.stats?.total_media_removed || 0;
                    document.getElementById('scheduledRemovals').textContent = data.stats?.scheduled_removals || 0;
                    
                    // Update cache removal schedule
                    updateCacheRemovalSchedule(data.cache_removal_schedule);
                    
                    // Update user activity status
                    updateUserActivityStatus(data.user_activity_status);
                    
                    // Update watch history
                    updateWatchHistory(data.watch_history);
                })
                .catch(error => {
                    console.error('Error updating watcher info:', error);
                });
        }
        
        function updateCacheRemovalSchedule(schedule) {
            const container = document.getElementById('cacheRemovalSchedule');
            if (!schedule || Object.keys(schedule).length === 0) {
                container.innerHTML = '<p>No scheduled removals</p>';
                return;
            }
            
            const currentTime = Math.floor(Date.now() / 1000);
            let html = '<div class="removal-list">';
            
            for (const [mediaKey, removalTime] of Object.entries(schedule)) {
                const timeUntilRemoval = removalTime - currentTime;
                const hours = Math.floor(timeUntilRemoval / 3600);
                const minutes = Math.floor((timeUntilRemoval % 3600) / 60);
                
                html += `<div class="removal-item">
                    <div class="removal-media">Media ID: ${mediaKey}</div>
                    <div class="removal-time">Removes in: ${hours}h ${minutes}m</div>
                </div>`;
            }
            
            html += '</div>';
            container.innerHTML = html;
        }
        
        function updateUserActivityStatus(userActivity) {
            const container = document.getElementById('userActivityStatus');
            if (!userActivity || Object.keys(userActivity).length === 0) {
                container.innerHTML = '<p>No user activity data</p>';
                return;
            }
            
            let html = '<div class="user-list">';
            
            for (const [username, status] of Object.entries(userActivity)) {
                const lastActivity = new Date(status.last_activity * 1000).toLocaleString();
                const statusClass = status.is_active ? 'user-active' : 'user-inactive';
                
                html += `<div class="user-item ${statusClass}">
                    <div class="user-name">${username}</div>
                    <div class="user-details">
                        <span>Last activity: ${lastActivity}</span>
                        <span>Days since: ${status.days_since.toFixed(1)}</span>
                        <span class="status-badge">${status.is_active ? 'Active' : 'Inactive'}</span>
                    </div>
                </div>`;
            }
            
            html += '</div>';
            container.innerHTML = html;
        }
        
        function updateWatchHistory(history) {
            const container = document.getElementById('watchHistoryContent');
            if (!history || Object.keys(history).length === 0) {
                container.innerHTML = '<p>No watch history</p>';
                return;
            }
            
            let html = '<div class="history-list">';
            
            for (const [mediaKey, item] of Object.entries(history)) {
                const timestamp = new Date(item.timestamp * 1000).toLocaleString();
                
                html += `<div class="history-item">
                    <div class="history-title">${item.title}</div>
                    <div class="history-details">
                        <span class="history-type">${item.type}</span>
                        <span class="history-reason">${item.reason}</span>
                        <span class="history-time">${timestamp}</span>
                    </div>
                </div>`;
            }
            
            html += '</div>';
            container.innerHTML = html;
        }
        
        // Update status every 5 seconds when on dashboard tab
        setInterval(() => {
            if (document.getElementById('dashboard').classList.contains('active')) {
                updateStatus();
                updateWatcherInfo();
            }
        }, 5000);
        
        // Update logs every 10 seconds when on logs tab
        setInterval(() => {
            if (document.getElementById('logs').classList.contains('active')) {
                loadLogs();
            }
        }, 10000);
        
        // Initialize dashboard
        updateStatus();

        // Load logs when logs tab is shown
        function loadLogs() {
            fetch('/api/logs')
                .then(response => response.json())
                .then(data => {
                    const logContainer = document.getElementById('logContainer');
                    
                    if (data.error) {
                        logContainer.innerHTML = `<div class="log-entry log-error">Error loading logs: ${data.error}</div>`;
                        return;
                    }
                    
                    if (!data.data.logs || data.data.logs.length === 0) {
                        logContainer.innerHTML = '<div class="log-entry log-info">No logs available</div>';
                        return;
                    }
                    
                    let html = '';
                    data.data.logs.forEach(log => {
                        const logClass = `log-${log.level}`;
                        html += `<div class="log-entry ${logClass}">${log.message}</div>`;
                    });
                    
                    logContainer.innerHTML = html;
                    
                    // Auto-scroll to bottom
                    logContainer.scrollTop = logContainer.scrollHeight;
                })
                .catch(error => {
                    console.error('Error loading logs:', error);
                    document.getElementById('logContainer').innerHTML = 
                        '<div class="log-entry log-error">Error loading logs. Check console for details.</div>';
                });
        }
        
        function refreshLogs() {
            loadLogs();
        }
        
        function clearLogs() {
            document.getElementById('logContainer').innerHTML = '<div class="log-entry log-info">Logs cleared</div>';
        }

        // Trakt.tv Functions
        function startTraktWatcher() {
            fetch('/api/trakt/start', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        showNotification('Trakt.tv watcher started successfully', 'success');
                        refreshTraktData();
                    } else {
                        showNotification('Failed to start Trakt.tv watcher', 'error');
                    }
                })
                .catch(error => {
                    showNotification('Error starting Trakt.tv watcher: ' + error, 'error');
                });
        }
        
        function stopTraktWatcher() {
            fetch('/api/trakt/stop', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        showNotification('Trakt.tv watcher stopped successfully', 'success');
                        refreshTraktData();
                    } else {
                        showNotification('Failed to stop Trakt.tv watcher', 'error');
                    }
                })
                .catch(error => {
                    showNotification('Error stopping Trakt.tv watcher: ' + error, 'error');
                });
        }
        
        function clearTraktHistory() {
            if (confirm('Are you sure you want to clear all Trakt.tv history?')) {
                fetch('/api/trakt/clear-history', { method: 'POST' })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            showNotification('Trakt.tv history cleared successfully', 'success');
                            refreshTraktData();
                        } else {
                            showNotification('Failed to clear Trakt.tv history', 'error');
                        }
                    })
                    .catch(error => {
                        showNotification('Error clearing Trakt.tv history: ' + error, 'error');
                    });
            }
        }
        
        function refreshTraktData() {
            fetch('/api/trakt/status')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        updateTraktStatus(data.stats);
                        updateTrendingMovies(data.trending_movies);
                    }
                })
                .catch(error => {
                    console.error('Error fetching Trakt data:', error);
                });
        }
        
        function updateTraktStatus(stats) {
            document.getElementById('traktStatus').textContent = stats.is_watching ? 'Running' : 'Stopped';
            document.getElementById('traktMovieCount').textContent = stats.trending_movies_count || 0;
            document.getElementById('traktLastCheck').textContent = stats.last_check || 'Never';
            document.getElementById('traktMoviesAdded').textContent = stats.movies_added || 0;
            document.getElementById('traktMoviesRemoved').textContent = stats.movies_removed || 0;
        }
        
        function updateTrendingMovies(movies) {
            const container = document.getElementById('trendingMoviesList');
            if (!movies || movies.length === 0) {
                container.innerHTML = '<p>No trending movies available</p>';
                return;
            }
            
            let html = '';
            for (const movie of movies) {
                const addedDate = new Date(movie.added_at).toLocaleDateString();
                const lastUpdated = new Date(movie.last_updated).toLocaleDateString();
                
                html += `
                    <div class="movie-item">
                        <div class="movie-title">${movie.title} (${movie.year})</div>
                        <div class="movie-details">
                            <div data-label="Added:">${addedDate}</div>
                            <div data-label="Last Updated:">${lastUpdated}</div>
                            <div data-label="Trakt ID:">${movie.trakt_id}</div>
                        </div>
                    </div>
                `;
            }
            container.innerHTML = html;
        }
    </script>
</body>
</html>

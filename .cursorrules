# Cacherr - Cursor Rules

## Project Overview

Cacherr is an intelligent Plex media caching system for Unraid that automatically moves frequently accessed media to fast SSD storage based on what users are watching. It uses Flask with Flask-SocketIO for the backend and React with TypeScript for the frontend.

## Tech Stack

- **Backend:** Python 3.11+, Flask, Flask-SocketIO, Pydantic v2.5, plexapi
- **Frontend:** React 18, TypeScript 5.x, TailwindCSS
- **Database:** SQLite with SQLAlchemy ORM
- **Real-time:** WebSocket via Flask-SocketIO
- **Deployment:** Docker, Unraid

## Code Standards

### Python

1. **Use Pydantic models** for all configuration - see `src/config/settings.py`
2. **Type hints everywhere** - no untyped functions
3. **Use dataclasses** for simple data structures
4. **Logging over print:** `logging.info()` not `print()`
5. **Thread safety:** Use `threading.RLock()` for shared state

### TypeScript

1. **Use existing interfaces** from `frontend/src/types/cache.ts` - never create duplicates
2. **Import types properly:** `import type { CacheStats } from '../types/cache'`
3. **No `any` types** - use `unknown` if type is truly unknown
4. **Props interface naming:** `{ComponentName}Props`

### React Components

1. **Functional components only** with hooks
2. **Handle all states:** loading, error, empty, success
3. **Use WebSocket hook** for real-time data:
   ```typescript
   // âœ… Good - real-time updates
   const { lastMessage, isConnected } = useWebSocket({
     url: `ws://${window.location.host}/ws/events`
   })
   
   // âŒ Bad - polling when WebSocket available
   setInterval(() => fetchData(), 1000)
   ```
4. **Support keyboard navigation** where appropriate
5. **Use API service** from `frontend/src/services/api.ts`

### Styling

1. **TailwindCSS only** - no inline styles except dynamic values
2. **Support dark mode** - use `dark:` variant classes
3. **Health status colors:**
   - Healthy: `text-green-500` / `bg-green-500`
   - Moderate: `text-yellow-500` / `bg-yellow-500`
   - Warning: `text-orange-500` / `bg-orange-500`
   - Critical: `text-red-500` / `bg-red-500`
4. **Source type badges:**
   - OnDeck: `bg-blue-100 text-blue-800`
   - Watchlist: `bg-purple-100 text-purple-800`
   - Lists: `bg-green-100 text-green-800`

## File Organization

### Backend
```
src/
â”œâ”€â”€ config/
â”‚   â””â”€â”€ settings.py      # Pydantic settings models
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ cache_manager.py # Central orchestrator - coordinates all operations
â”‚   â”œâ”€â”€ file_operations.py # Atomic symlink operations
â”‚   â”œâ”€â”€ plex_client.py   # Rate-limited Plex API client
â”‚   â”œâ”€â”€ trackers.py      # Cache/Watchlist/OnDeck tracking
â”‚   â”œâ”€â”€ user_manager.py  # User discovery and settings
â”‚   â”œâ”€â”€ broadcaster.py   # WebSocket event emission
â”‚   â””â”€â”€ lock.py          # Instance lock
â”œâ”€â”€ lists/
â”‚   â”œâ”€â”€ manager.py       # Import lists orchestration
â”‚   â”œâ”€â”€ matcher.py       # Plex library matching
â”‚   â””â”€â”€ providers/       # Trakt, TMDb, IMDb, RSS providers
â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ routes.py        # REST API endpoints
â”‚   â””â”€â”€ websocket.py     # WebSocket handlers
â””â”€â”€ db/
    â”œâ”€â”€ schema.py        # SQLAlchemy models
    â””â”€â”€ repository.py    # Data access layer
```

### Frontend
```
frontend/src/
â”œâ”€â”€ types/
â”‚   â””â”€â”€ cache.ts         # All TypeScript interfaces
â”œâ”€â”€ services/
â”‚   â””â”€â”€ api.ts           # API service with typed methods
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ useWebSocket.ts  # WebSocket connection hook
â”‚   â””â”€â”€ useApi.ts        # API query hooks
â”œâ”€â”€ pages/
â”‚   â”œâ”€â”€ Dashboard.tsx    # Main dashboard
â”‚   â”œâ”€â”€ Users.tsx        # User management
â”‚   â”œâ”€â”€ ImportLists.tsx  # Import lists management
â”‚   â””â”€â”€ Settings.tsx     # Configuration
â””â”€â”€ components/
    â”œâ”€â”€ StatsCards.tsx
    â”œâ”€â”€ ActiveOperations.tsx
    â”œâ”€â”€ SessionList.tsx
    â””â”€â”€ ...
```

## Naming Conventions

- **Python files:** snake_case (`cache_manager.py`)
- **Python classes:** PascalCase (`CacheManager`)
- **Python functions:** snake_case (`get_cache_stats`)
- **TypeScript components:** PascalCase (`Dashboard.tsx`)
- **TypeScript hooks:** camelCase with `use` prefix (`useWebSocket.ts`)
- **Constants:** SCREAMING_SNAKE_CASE (`MAX_CONCURRENT_MOVES`)

## Reference Files

When building features, always check:

1. **`docs/ARCHITECTURE.md`** - Project structure and component overview
2. **`docs/FEATURE_PARITY.md`** - What features are implemented/needed
3. **`docs/USER_MANAGEMENT_DESIGN.md`** - User types and settings
4. **`docs/IMPORT_LISTS_DESIGN.md`** - Import lists system
5. **`docs/REALTIME_WEBGUI_DESIGN.md`** - WebSocket events and UI updates
6. **`docs/TASKS.md`** - Development task breakdown
7. **`frontend/src/types/cache.ts`** - All TypeScript interfaces

## Common Patterns

### Rate-Limited Plex API Calls

```python
# Always use the rate-limited client
class PlexClient:
    def _wait_for_rate_limit(self):
        """Enforce rate limiting to protect Plex SQLite."""
        with self._lock:
            elapsed = time.time() - self._last_request
            if elapsed < self.min_interval:
                time.sleep(self.min_interval - elapsed)
            self._last_request = time.time()
    
    def get_sessions(self):
        self._wait_for_rate_limit()  # Always call this first!
        return self._server.sessions()
```

### Emitting WebSocket Events

```python
# In cache_manager.py or file_operations.py
from src.core.broadcaster import broadcaster

# Emit progress during file copy
broadcaster.emit_operation_progress(operation_id, {
    'operation_type': 'cache',
    'file_name': file_name,
    'progress_percent': progress,
    'speed_bytes_per_sec': speed,
})

# Emit completion
broadcaster.emit_operation_complete(operation_id, {
    'operation_type': 'cache',
    'file_path': dst_path,
    'success': True,
    'duration_seconds': duration,
})
```

### Using Settings

```python
from src.config.settings import get_settings

settings = get_settings()

# Access nested settings
if settings.cache_limits.eviction_mode == 'smart':
    # Use smart eviction
    pass

# Check user type defaults
home_defaults = settings.users.home_user_defaults
if home_defaults.ondeck_enabled:
    # Cache OnDeck for home users
    pass
```

### Frontend WebSocket Hook

```typescript
import { useWebSocket } from '../hooks/useWebSocket'

const MyComponent: React.FC = () => {
  const { lastMessage, isConnected } = useWebSocket({
    url: `ws://${window.location.host}/ws/events`,
  })
  
  useEffect(() => {
    if (!lastMessage) return
    
    switch (lastMessage.type) {
      case 'operation_progress':
        // Update progress bar
        break
      case 'stats':
        // Update stats display
        break
    }
  }, [lastMessage])
  
  return (
    <div>
      {isConnected ? 'ğŸŸ¢ Connected' : 'ğŸ”´ Disconnected'}
    </div>
  )
}
```

### API Calls from Frontend

```typescript
import * as api from '../services/api'

// Always use typed API methods
const handleRunCycle = async () => {
  const result = await api.runCacheCycle()
  if (result.success) {
    // Handle success
  } else {
    setError(result.error)
  }
}
```

## Do Not

### Backend
1. âŒ Make Plex API calls without rate limiting
2. âŒ Use `print()` instead of `logging`
3. âŒ Modify shared state without locks
4. âŒ Hardcode paths - use settings
5. âŒ Skip error handling on file operations
6. âŒ Forget to emit events for UI updates

### Frontend
1. âŒ Create new interfaces if one exists in `types/cache.ts`
2. âŒ Use polling when WebSocket is available
3. âŒ Skip loading/error/empty states
4. âŒ Hardcode API URLs
5. âŒ Use `any` types
6. âŒ Skip dark mode support

## Key Concepts

### User Types
- **Main** - Server owner (highest priority)
- **Home** - Family on same Plex Home
- **Shared** - Remote friends (lowest default priority)

### Cache Sources
- **ondeck** - Currently watching episodes
- **watchlist** - User watchlists
- **list:{id}** - Import lists
- **active_watching** - Currently playing

### Priority Scoring (0-100)
- Active playback: 100 (never evict)
- OnDeck source: +20
- Watchlist source: +10
- Multiple users: +5 per user
- Recently cached: +5 to +15
- Current episode position: +15

### Atomic Operations
Files are cached without interrupting Plex playback:
1. Copy file to cache
2. Create `.plexcached` backup of original
3. Atomic rename original â†’ backup
4. Create symlink original â†’ cache
5. Plex file descriptors remain valid

## Testing

```python
# Backend tests use pytest
import pytest
from src.core.cache_manager import CacheManager

def test_priority_calculation():
    manager = CacheManager(...)
    priority = manager.calculate_priority('/path/to/file')
    assert 0 <= priority <= 100
```

```typescript
// Frontend tests use Vitest
import { render, screen } from '@testing-library/react'
import { StatsCards } from './StatsCards'

describe('StatsCards', () => {
  it('displays cache size', () => {
    render(<StatsCards stats={mockStats} />)
    expect(screen.getByText('250 GB')).toBeInTheDocument()
  })
})
```

## When You Need Help

- **Complex architecture decisions** â†’ Read `docs/ARCHITECTURE.md`, ask Claude
- **User management logic** â†’ Read `docs/USER_MANAGEMENT_DESIGN.md`
- **Import lists implementation** â†’ Read `docs/IMPORT_LISTS_DESIGN.md`
- **Real-time updates** â†’ Read `docs/REALTIME_WEBGUI_DESIGN.md`
- **Task-specific guidance** â†’ Read `docs/TASKS.md`
- **API endpoint list** â†’ Check `src/api/routes.py`
- **Type definitions** â†’ Check `frontend/src/types/cache.ts`

## Environment

- Docker container runs on Unraid
- Config stored in `/config` volume
- Cache destination in `/cache` volume
- Media sources mounted to `/media`, `/media2`, etc.
- WebGUI on port 5445

## Version

This rules file is for Cacherr fresh implementation.
Last updated: January 6, 2026
